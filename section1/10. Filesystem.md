[toc]

# 1. Filesystem

## 1. Overview

- What is a filesystem? - 顾名思义，就是组织(organize)文件的系统

- 硬盘不能直接存放文件or数据；通过将硬盘格式化后，指定格式化后的文件系统才能存放

- 不同的文件系统存放文件的方式也不同

  

- Windows文件系统 - `NTFS`

  - 在安装过程中，驱动会识别出硬盘，人为对其进行分区 + 格式化，然后安装操作系统
    - “我的电脑” -> 右键“管理” -> 存储 - “磁盘管理” -> 添加硬盘 -> 初始化硬盘 -> 选择分区格式(MBR/GPT) -> 初始化后状态为“联机” -> 新建简单卷向导 -> 格式化（确定确实没有任何数据才去格式化）-> 文件系统会占一定的空间
  - 想要使用已经有文件系统的分区，必须要进行挂载(mount)，Windows中有2种方式 - 给文件系统分配盘符(C/D/E...) & 同Linux，将文件挂在到一个目录(可非空)
    - 右键“更改驱动器号和路径”

## 2. MBR & GPT

- `MBR` - Master Boot Record - 主引导记录

  - 当想创建第4个主分区的时候，会将剩下的所有空间划分成扩展分区，然后在扩展分区中划出一部分作为逻辑分区

  - 最多可创建3个主分区 + 扩展分区

  - 单分区大小不超过2TB

  - 如果硬盘选择MBR格式进行初始化，那么磁盘的第一个扇区(sector)一定是512B

    - ==∵只有4个硬盘分区表项，每个表项16Bytes，共64Bytes；∴最多只能4个分区==

    

- `GPT` - Globally Unique Identifier Partition Table

  - 最多可以创建1024个主分区 + 扩展分区
  - 单分区大小不超过18EB

## 3. Linux

### 1. Partition

- 早期`IDE`硬盘会被识别为`/dev/hd*`

- `SATA` & `SCSI` 硬盘会被识别为`/dev/sd*`

- 对于服务器磁盘使用目的：

  1. 存放操作系统 + 配置文件
  2. 存放本地大文件 - 本地存储盘
  3. 存放本地大文件 - 使用`SAN` - Storage Area Network - 网络存储盘

  

- 查看设备文件

  ```bash
  # b - block device
  # sda  - 第1块硬盘
  # sda1 - 第1块硬盘的第2个分区
  # sda2 - 第2块硬盘的第1个分区
  # sdb  - 第2块硬盘
  [root@RHEL8-RHCE tutorj]$ ll /dev/sd*
  brw-rw----. 1 root disk 8,  0 Jan 27 08:39 /dev/sda
  brw-rw----. 1 root disk 8,  1 Jan 27 08:39 /dev/sda1
  brw-rw----. 1 root disk 8,  2 Jan 27 08:39 /dev/sda2
  brw-rw----. 1 root disk 8, 16 Jan 27 08:39 /dev/sdb
  ```

- 手动分区 - ==添加硬盘 -> 分区 -> 格式化 -> 挂载==

  ```bash
  # 分区
  # if MBR -> fdisk
  # if GPT -> gdisk，如果想要超过2TB的磁盘分区，必须采用gdisk
  
  # 查看当前所有硬盘的分区情况
  [root@RHEL8-RHCE tutorj]$ fdisk -l
  Disk /dev/sda: 15 GiB, 16106127360 bytes, 31457280 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xfecd8079
  
  Device     Boot   Start      End  Sectors Size Id Type
  /dev/sda1  *       2048  2099199  2097152   1G 83 Linux
  /dev/sda2       2099200 31457279 29358080  14G 8e Linux LVM
  
  # 10GiB = 10 * 1024 * 1024 * 1024 Bytes
  # 1 sector = 512 Bytes
  Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  
  Disk /dev/mapper/rhel-root: 12.5 GiB, 13417578496 bytes, 26206208 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  
  Disk /dev/mapper/rhel-swap: 1.5 GiB, 1610612736 bytes, 3145728 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  
  # 查看指定硬盘的分区情况
  [root@RHEL8-RHCE tutorj]$ fdisk -l /dev/sdc
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  
  # 交互式
  [root@RHEL8-RHCE tutorj]$ fdisk /dev/sdc
  Welcome to fdisk (util-linux 2.32.1).
  Changes will remain in memory only, until you decide to write them.
  Be careful before using the write command.
  
  Device does not contain a recognized partition table.
  Created a new DOS disklabel with disk identifier 0xee49a439.	# 硬盘第一次初始化会提示创建标识 - 写入512MBR
  
  Command (m for help): w		# save
  The partition table has been altered.
  Calling ioctl() to re-read partition table.
  Syncing disks.
  
  # check again - 没有提示创建标识说明已经初始化过了
  [root@RHEL8-RHCE tutorj]$ fdisk /dev/sdc
  Welcome to fdisk (util-linux 2.32.1).
  Changes will remain in memory only, until you decide to write them.
  Be careful before using the write command.
  
  Command (m for help): m
  
  Help:
  
    DOS (MBR)
     a   toggle a bootable flag
     b   edit nested BSD disklabel
     c   toggle the dos compatibility flag
  
    Generic
     d   delete a partition					# 删除一个分区
     F   list free unpartitioned space
     l   list known partition types			# 列出当前支持的分区种类
     n   add a new partition					# 添加一个新的分区
     p   print the partition table			# 列出当前磁盘的所有分区
     t   change a partition type				# 修改分区类型（没有实际意义）
     v   verify the partition table
     i   print information about a partition
  
    Misc
     m   print this menu
     u   change display/entry units
     x   extra functionality (experts only)
  
    Script
     I   load disk layout from sfdisk script file
     O   dump disk layout to sfdisk script file
  
    Save & Exit
     w   write table to disk and exit
     q   quit without saving changes
  
    Create a new label
     g   create a new empty GPT partition table
     G   create a new empty SGI (IRIX) partition table
     o   create a new empty DOS partition table
     s   create a new empty Sun partition table
  
  # add a new parition
  Command (m for help): n
  Partition type
     p   primary (0 primary, 0 extended, 4 free)
     e   extended (container for logical partitions)
  # primary type
  Select (default p): p
  Partition number (1-4, default 1): 1
  First sector (2048-8388607, default 2048): 2048
  Last sector, +sectors or +size{K,M,G,T,P} (2048-8388607, default 8388607): 52047
  
  # 52047 - 2048 = 50000 * 512 / 1024 / 1024 = 24.4MiB
  Created a new partition 1 of type 'Linux' and of size 24.4 MiB.
  
  # print
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot Start   End Sectors  Size Id Type
  /dev/sdc1        2048 52047   50000 24.4M 83 Linux
  
  # delete
  Command (m for help): d
  Selected partition 1
  Partition 1 has been deleted.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  # x - <start sector> + 1 = 1 * 1024 * 1024 * 1024 / 512
  Select (default p): p
  Partition number (1-4, default 1):
  First sector (2048-8388607, default 2048):
  Last sector, +sectors or +size{K,M,G,T,P} (2048-8388607, default 8388607): 2099199
  
  Created a new partition 1 of type 'Linux' and of size 1 GiB.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot Start     End Sectors Size Id Type
  /dev/sdc1        2048 2099199 2097152   1G 83 Linux
  
  # add one more
  Command (m for help): n
  Partition type
     p   primary (1 primary, 0 extended, 3 free)
     e   extended (container for logical partitions)
  Select (default p): p
  Partition number (2-4, default 2):
  First sector (2099200-8388607, default 2099200):
  # much easier
  Last sector, +sectors or +size{K,M,G,T,P} (2099200-8388607, default 8388607): +1G
  
  Created a new partition 2 of type 'Linux' and of size 1 GiB.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdc1          2048 2099199 2097152   1G 83 Linux
  /dev/sdc2       2099200 4196351 2097152   1G 83 Linux
  
  # save
  Command (m for help): w
  The partition table has been altered.
  Calling ioctl() to re-read partition table.
  Syncing disks.
  
  [root@RHEL8-RHCE tutorj]$ ls /dev/sdc*
  /dev/sdc  /dev/sdc1  /dev/sdc2
  
  # create 2 more
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdc1          2048 2099199 2097152   1G 83 Linux
  /dev/sdc2       2099200 4196351 2097152   1G 83 Linux
  /dev/sdc3       4196352 4216831   20480  10M 83 Linux
  /dev/sdc4       4216832 4237311   20480  10M 83 Linux
  
  # warning, only 4 primary allowed
  Command (m for help): n
  To create more partitions, first replace a primary with an extended partition.
  
  # all rest for extended 
  # 注意：其中会腾出2048Bytes用于扩展分区的逻辑划分表 = 就像是主分区一开始预留的64Bytes - 4 primary partitions
  # 逻辑分区处于扩展分区中！
  Command (m for help): n
  Partition type
     p   primary (3 primary, 0 extended, 1 free)
     e   extended (container for logical partitions)
  Select (default e): e
  
  Selected partition 4
  First sector (4216832-8388607, default 4216832):
  Last sector, +sectors or +size{K,M,G,T,P} (4216832-8388607, default 8388607):
  
  Created a new partition 4 of type 'Extended' and of size 2 GiB.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdc1          2048 2099199 2097152   1G 83 Linux
  /dev/sdc2       2099200 4196351 2097152   1G 83 Linux
  /dev/sdc3       4196352 4216831   20480  10M 83 Linux
  /dev/sdc4       4216832 8388607 4171776   2G  5 Extended
  
  # add logic parition
  Command (m for help): n
  All primary partitions are in use.
  Adding logical partition 5
  First sector (4218880-8388607, default 4218880):
  Last sector, +sectors or +size{K,M,G,T,P} (4218880-8388607, default 8388607): +500M
  
  Created a new partition 5 of type 'Linux' and of size 500 MiB.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors  Size Id Type
  /dev/sdc1          2048 2099199 2097152    1G 83 Linux
  /dev/sdc2       2099200 4196351 2097152    1G 83 Linux
  /dev/sdc3       4196352 4216831   20480   10M 83 Linux
  /dev/sdc4       4216832 8388607 4171776    2G  5 Extended
  /dev/sdc5       4218880 5242879 1024000  500M 83 Linux
  
  # 一般一个主分区剩下的都给逻辑分区，然后在逻辑分区中再细分
  Command (m for help): n
  Partition type
     p   primary (1 primary, 0 extended, 3 free)
     e   extended (container for logical partitions)
  Select (default p): e
  Partition number (2-4, default 2):
  First sector (2099200-8388607, default 2099200):
  Last sector, +sectors or +size{K,M,G,T,P} (2099200-8388607, default 8388607): 3G
  Value out of range.
  Last sector, +sectors or +size{K,M,G,T,P} (2099200-8388607, default 8388607):
  
  Created a new partition 2 of type 'Extended' and of size 3 GiB.
  
  Command (m for help): p
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdc1          2048 2099199 2097152   1G 83 Linux
  /dev/sdc2       2099200 8388607 6289408   3G  5 Extended
  ```

- 自动创建分区 - ==输入重定向==

  ```bash
  [root@RHEL8-RHCE tutorj]$ cat test_partition
  n
  p
  1
  
  +1G
  w
  [root@RHEL8-RHCE tutorj]$ fdisk /dev/sdc < test_partition 2&>1 /dev/null && fdisk -l /dev/sdc
  
  Welcome to fdisk (util-linux 2.32.1).
  Changes will remain in memory only, until you decide to write them.
  Be careful before using the write command.
  
  
  Command (m for help): Partition type
     p   primary (0 primary, 0 extended, 4 free)
     e   extended (container for logical partitions)
  Select (default p): Partition number (1-4, default 1): First sector (2048-8388607, default 2048): Last sector, +sectors or +size{K,M,G,T,P} (2048-8388607, default 8388607):
  Created a new partition 1 of type 'Linux' and of size 1 GiB.
  
  Command (m for help): The partition table has been altered.
  Calling ioctl() to re-read partition table.
  Syncing disks.
  
  [root@RHEL8-RHCE tutorj]$ fdisk -l /dev/sdc
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot Start     End Sectors Size Id Type
  /dev/sdc1        2048 2099199 2097152   1G 83 Linux
  ```

### 2. Formatting

- 分区只有格式化之后才能使用 = 格式化相当于给分区做了一个文件系统

- Linux常见文件系统

  - ext2/3/4(单文件最大1TB)

  - xfs（单文件最大16TB）- default since RHEL7

  - btrfs

    

- 如果设计到文件系统性能的需求，首先需要直到要存储文件的特征 - 文件数量 & 文件大小

  

- ==格式化原理==

  - 格式化前

    - 分区的最小单位 - `sector` - 512Bytes

    - 假如分区可以直接使用，存储一个20M的文件需要20 * 1024 * 1024 / 512 = 40960个`sector`，那么读取这个20M的文件就需要读40960次，神一般的效率= =

      

  - 格式化后

    - **会立刻分配`inode`空间（存放元数据 - 属性 & 权限 & 对应block的位置），剩下的给`block`空间（多个`sector`的集合 - 存放数据）- 将硬盘的读写的粒度“放大”**

      - **通过`inode`定位到`block`的位置**
      - **如果`inode`使用完了，即便还有多余的`block`的空间，但依旧无法创建新文件**
      - **格式化创建文件系统时可以指定`inode` & `block`的大小**

    - 1 * `block` = 2^n `sector`

    - `block`越大，读写的效率越高（一次性读写的`sector`就越多）

    - 当然也不是绝对，加入一个`block`为0.5M，那么存1K的小文件就浪费了很多空间

      

  ```bash
  # ready
  [root@RHEL8-RHCE tutorj]$ fdisk -l /dev/sdc
  Disk /dev/sdc: 4 GiB, 4294967296 bytes, 8388608 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0xee49a439
  
  Device     Boot   Start     End Sectors  Size Id Type
  /dev/sdc1          2048 6293503 6291456    3G  5 Extended
  /dev/sdc5          4096 2101247 2097152    1G 83 Linux
  /dev/sdc6       2103296 4200447 2097152    1G 83 Linux
  /dev/sdc7       4202496 5226495 1024000  500M 83 Linux
  
  # supported filesystem to format
  [root@RHEL8-RHCE tutorj]$ mkfs
  mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.ext4    
  mkfs.fat     mkfs.minix   mkfs.msdos   mkfs.vfat    mkfs.xfs
  
  # sdc5 -> ext2
  [root@RHEL8-RHCE tutorj]$ mkfs.ext2 /dev/sdc5
  mke2fs 1.45.6 (20-Mar-2020)
  Creating filesystem with 262144 4k blocks and 65536 inodes
  Filesystem UUID: c9739ed3-65cf-4f9f-bd2f-db753662aba9
  Superblock backups stored on blocks:
          32768, 98304, 163840, 229376
  
  Allocating group tables: done
  Writing inode tables: done
  Writing superblocks and filesystem accounting information: done
  
  # sdc6 -> xfs
  [root@RHEL8-RHCE tutorj]$ mkfs.xfs /dev/sdc6
  meta-data=/dev/sdc6              isize=512    agcount=4, agsize=65536 blks
           =                       sectsz=512   attr=2, projid32bit=1
           =                       crc=1        finobt=1, sparse=1, rmapbt=0
           =                       reflink=1    bigtime=0 inobtcount=0
  data     =                       bsize=4096   blocks=262144, imaxpct=25
           =                       sunit=0      swidth=0 blks
  naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
  log      =internal log           bsize=4096   blocks=2560, version=2
           =                       sectsz=512   sunit=0 blks, lazy-count=1
  realtime =none                   extsz=4096   blocks=0, rtextents=0
  
  # sdc7 -> fat
  [root@RHEL8-RHCE tutorj]$ mkfs.fat /dev/sdc7
  mkfs.fat 4.1 (2017-01-24)
  
  ```


### 3. Mount

- 针对文件系统（格式化后的分区）而非分区

- `mount` - mount a filesystem

  ```bash
  # make directories
  [root@RHEL8-RHCE tutorj]$ mkdir /mount-point{1..3}
  
  # mount - temp only
  [root@RHEL8-RHCE tutorj]$ mount /dev/sdc5 /mount-point1
  [root@RHEL8-RHCE tutorj]$ mount /dev/sdc6 /mount-point2
  [root@RHEL8-RHCE tutorj]$ mount /dev/sdc7 /mount-point3
  
  # check 
  [root@RHEL8-RHCE tutorj]$ df -Th
  Filesystem            Type      Size  Used Avail Use% Mounted on
  devtmpfs              devtmpfs  877M     0  877M   0% /dev
  tmpfs                 tmpfs     907M     0  907M   0% /dev/shm
  tmpfs                 tmpfs     907M  988K  906M   1% /run
  tmpfs                 tmpfs     907M     0  907M   0% /sys/fs/cgroup
  /dev/mapper/rhel-root xfs        13G  8.1G  4.5G  65% /
  /dev/sda1             xfs      1014M  342M  673M  34% /boot
  tmpfs                 tmpfs     1.0M     0  1.0M   0% /run/stratisd/keyfiles
  tmpfs                 tmpfs     182M  4.0K  182M   1% /run/user/1000
  /dev/sdc5             ext2     1007M   24K  956M   1% /mount-point1
  /dev/sdc6             xfs      1014M   40M  975M   4% /mount-point2
  /dev/sdc7             vfat      500M     0  500M   0% /mount-point3
  
  # check one specific
  [root@RHEL8-RHCE tutorj]$ df -Th /dev/sdc5
  Filesystem     Type  Size  Used Avail Use% Mounted on
  /dev/sdc5      ext2 1007M   24K  956M   1% /mount-point1
  
  # check inode usage
  [root@RHEL8-RHCE tutorj]$ df -i
  Filesystem             Inodes  IUsed   IFree IUse% Mounted on
  devtmpfs               224505    444  224061    1% /dev
  tmpfs                  232030      1  232029    1% /dev/shm
  tmpfs                  232030    817  231213    1% /run
  tmpfs                  232030     17  232013    1% /sys/fs/cgroup
  /dev/mapper/rhel-root 6551552 203964 6347588    4% /
  /dev/sda1              524288    317  523971    1% /boot
  tmpfs                  232030      1  232029    1% /run/stratisd/keyfiles
  tmpfs                  232030     12  232018    1% /run/user/1000
  /dev/sdc5               65536     11   65525    1% /mount-point1
  /dev/sdc6              524288      3  524285    1% /mount-point2
  /dev/sdc7                   0      0       0     - /mount-point3
  [root@RHEL8-RHCE tutorj]$ df -i /dev/sdc5
  Filesystem     Inodes IUsed IFree IUse% Mounted on
  /dev/sdc5       65536    11 65525    1% /mount-point1
  
  # 列出当前所有文件系统的挂载情况
  [root@RHEL8-RHCE tutorj]$ mount
  sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
  proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
  devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=898020k,nr_inodes=224505,mode=755)
  securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
  ...
  tracefs on /sys/kernel/debug/tracing type tracefs (rw,relatime,seclabel)
  tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=185624k,mode=700,uid=1000,gid=1000)
  gvfsd-fuse on /run/user/1000/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_id=1000,group_id=1000)
  /dev/sdc5 on /mount-point1 type ext2 (rw,relatime,seclabel)
  /dev/sdc6 on /mount-point2 type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
  
  ```

- 持久性挂载 -> `/etc/fstab`

  - ==编辑前记得先备份！！！==

  ```bash
  # col#1 - 文件系统所在分区的路径
  # col#2 - 文件系统的挂载路径
  # col#3 - 文件系统类型
  # col#4 - 挂载参数
  # col#5 - 0 okay
  # col#6 - 0 okay
  [root@RHEL8-RHCE tutorj]$ cat /etc/fstab
  #
  # /etc/fstab
  # Created by anaconda on Tue Dec  6 15:11:39 2022
  #
  # Accessible filesystems, by reference, are maintained under '/dev/disk/'.
  # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
  #
  # After editing this file, run 'systemctl daemon-reload' to update systemd
  # units generated from this file.
  #
  /dev/mapper/rhel-root   /                       xfs     defaults        0 0
  UUID=ce024b35-079e-4c13-b285-63cfbd06fae3 /boot                   xfs     defaults        0 0
  /dev/mapper/rhel-swap   none                    swap    defaults        0 0
  
  # add entry
  [root@RHEL8-RHCE tutorj]$ cat /etc/fstab | grep sdc
  /dev/sdc5        /mount-point1   ext2    defaults        0       0
  /dev/sdc6        /mount-point2   xfs     defaults        0       0
  /dev/sdc7        /mount-point3   vfat    defaults        0       0
  /dev/sr1         /iso            iso9660 defaults        0       0	# 安装光盘
  
  #  Mount all filesystems (of the given types) mentioned in /etc/fstab
  [root@RHEL8-RHCE tutorj]$ mount -a
  
  # umount
  [root@RHEL8-RHCE iso]$ umount /iso
  
  # check block uuid
  # 只有格式化后的才会有UUID
  [root@RHEL8-RHCE iso]$ blkid
  /dev/sda1: UUID="ce024b35-079e-4c13-b285-63cfbd06fae3" BLOCK_SIZE="512" TYPE="xfs" PARTUUID="fecd8079-01"
  /dev/sda2: UUID="JWcK1C-F71Z-6MjS-TzWG-nhfP-OHP8-RiXjEr" TYPE="LVM2_member" PARTUUID="fecd8079-02"
  /dev/sdc5: UUID="c9739ed3-65cf-4f9f-bd2f-db753662aba9" BLOCK_SIZE="4096" TYPE="ext2" PARTUUID="ee49a439-05"
  /dev/sdc6: UUID="c2ec8308-4fae-42c5-9716-ff5daadd1755" BLOCK_SIZE="512" TYPE="xfs" PARTUUID="ee49a439-06"
  /dev/sdc7: SEC_TYPE="msdos" UUID="73DF-407B" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="ee49a439-07"
  /dev/sr0: BLOCK_SIZE="2048" UUID="2022-11-16-17-05-17-10" LABEL="VBox_GAs_7.0.4" TYPE="iso9660"
  /dev/sr1: BLOCK_SIZE="2048" UUID="2022-07-01-03-18-03-00" LABEL="RHEL-8-4-0-BaseOS-x86_64" TYPE="iso9660" PTUUID="04a1ad3f" PTTYPE="dos"
  /dev/mapper/rhel-root: UUID="6b0f033e-83c4-42e9-8ca3-45f1e4544419" BLOCK_SIZE="512" TYPE="xfs"
  /dev/mapper/rhel-swap: UUID="f9071724-7400-4b06-88bd-fcb6f58840ff" TYPE="swap"
  
  # pointing to
  # 只有格式化后的才会有UUID
  [root@RHEL8-RHCE iso]$ ll /dev/disk/by-uuid/
  total 0
  lrwxrwxrwx. 1 root root  9 Jan 28 15:50 2022-07-01-03-18-03-00 -> ../../sr1
  lrwxrwxrwx. 1 root root  9 Jan 28 15:50 2022-11-16-17-05-17-10 -> ../../sr0
  lrwxrwxrwx. 1 root root 10 Jan 28 15:50 6b0f033e-83c4-42e9-8ca3-45f1e4544419 -> ../../dm-0
  lrwxrwxrwx. 1 root root 10 Jan 28 16:05 73DF-407B -> ../../sdc7
  lrwxrwxrwx. 1 root root 10 Jan 28 16:05 c2ec8308-4fae-42c5-9716-ff5daadd1755 -> ../../sdc6
  lrwxrwxrwx. 1 root root 10 Jan 28 16:04 c9739ed3-65cf-4f9f-bd2f-db753662aba9 -> ../../sdc5
  lrwxrwxrwx. 1 root root 10 Jan 28 15:50 ce024b35-079e-4c13-b285-63cfbd06fae3 -> ../../sda1
  lrwxrwxrwx. 1 root root 10 Jan 28 15:50 f9071724-7400-4b06-88bd-fcb6f58840ff -> ../../dm-1
  ```

### 4. Logical Volume

- 此前的步骤：安装硬盘 -> 分区 -> 格式化 -> 挂载使用

- 使用`fdisk` or `gidsk`标准Linux分区然后进行格式化成文件系统挂载使用后，一旦空间满了，是无法扩容的:pensive:

  

- `pv` - physical volume - 物理卷（分区pool）

- `vg` - volume group    - 卷组

- `lv` - logical volume  - 逻辑卷

  

- 现在的步骤：分区 -> 加入`pv` -> 创建`vg` -> 创建`lv` -> 格式化`lv` -> 挂载使用

  - 理论上`pv`可以无限大 -> `vg`数量也是无限大 -> `lv`无限大 -> 文件系统使用的空间无限大

  

- `pv`创建&删除

  ```bash
  # partition first
  [root@RHEL8-RHCE iso]$ fdisk -l /dev/sdb
  Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0x2df31fa3
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdb1          2048 2099199 2097152   1G 83 Linux
  /dev/sdb2       2099200 6293503 4194304   2G 83 Linux
  
  # create pv
  [root@RHEL8-RHCE iso]$ pvcreate /dev/sdb1
  Physical volume "/dev/sdb1" successfully created.
  [root@RHEL8-RHCE iso]$ pvcreate /dev/sdb2
  Physical volume "/dev/sdb2" successfully created.
  
  # show pv
  [root@RHEL8-RHCE iso]$ pvs
  PV         VG   Fmt  Attr PSize   PFree
  /dev/sdb1       lvm2 ---    1.00g 1.00g
  /dev/sdb2       lvm2 ---    2.00g 2.00g
  
  # detail
  [root@RHEL8-RHCE iso]$ pvdisplay /dev/sdb1
  "/dev/sdb1" is a new physical volume of "1.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb1
  VG Name
  PV Size               1.00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               8OvLGX-F7Hg-yOrb-KWom-GdbZ-4jnB-iGnGXk
      
  # remove pv - 正在使用中的无法删除
  [root@RHEL8-RHCE iso]$ pvremove /dev/sdb1 /dev/sdb2
  Labels on physical volume "/dev/sdb1" successfully wiped.
  Labels on physical volume "/dev/sdb2" successfully wiped.
  
  # can also add unpartitioned disk directly
  [root@RHEL8-RHCE iso]$ pvcreate /dev/sdc
  Physical volume "/dev/sdc" successfully created.
  [root@RHEL8-RHCE iso]$ pvs
  PV         VG   Fmt  Attr PSize   PFree
  /dev/sda2  rhel lvm2 a--  <14.00g    0
  /dev/sdb1       lvm2 ---    1.00g 1.00g
  /dev/sdb2       lvm2 ---    2.00g 2.00g
  /dev/sdc        lvm2 ---    4.00g 4.00g
  ```
  
- `vg`创建/删除/扩容/缩容

  - 考点：`-s` - --physicalextentsize Size[m|UNIT] - 指定`pe`大小（`lv`划分成多个小`pe`）- 类似于`block`和`sector`的关系

  ```bash
  # create vg from pv
  # 也支持直接创建vg，linux会自动将分区加入到pv中
  [root@RHEL8-RHCE iso]$ vgcreate vg1 /dev/sdb1
  Volume group "vg1" successfully created
  [root@RHEL8-RHCE iso]$ vgs
  VG   #PV #LV #SN Attr   VSize    VFree
  vg1    1   0   0 wz--n- 1020.00m 1020.00m
  
  # remove vg - 其上有lv无法被删除
  [root@RHEL8-RHCE iso]$ vgremove vg1
  Volume group "vg1" successfully removed
  [root@RHEL8-RHCE iso]$ vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  
  # extend
  [root@RHEL8-RHCE iso]$ vgcreate vg1 /dev/sdb2
  Volume group "vg1" successfully created
  [root@RHEL8-RHCE iso]$ vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  rhel   1   2   0 wz--n- <14.00g     0
  vg1    1   0   0 wz--n-  <2.00g <2.00g
  [root@RHEL8-RHCE iso]$ vgextend vg1 /dev/sdb1
  Volume group "vg1" successfully extended
  Similar command is: 'vgs'
  [root@RHEL8-RHCE iso]$ vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  rhel   1   2   0 wz--n- <14.00g    0
  vg1    2   0   0 wz--n-   2.99g 2.99g
  
  # detail
  [root@RHEL8-RHCE iso]$ vgdisplay vg1
  --- Volume group ---
  VG Name               vg1
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  2
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               2.99 GiB
  PE Size               4.00 MiB	# 考点
  Total PE              766
  Alloc PE / Size       0 / 0
  Free  PE / Size       766 / 2.99 GiB
  VG UUID               UU1cJG-GkPA-zBVy-d6jq-k3UF-aIVY-c3q7vV
  ```
  
- `lv`创建/删除/扩容 - 创建完可直接格式化成文件系统挂载使用

  ```bash
  # create
  # -n - name of lv
  # -L - size of lv
  [root@RHEL8-RHCE iso]$ lvcreate -n lv1 -L 30M vg1
  Rounding up size to full physical extent 32.00 MiB
  Logical volume "lv1" created.
  
  # show
  [root@RHEL8-RHCE iso]$ lvs
  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root rhel -wi-ao---- <12.50g
  swap rhel -wi-ao----   1.50g
  lv1  vg1  -wi-a-----  32.00m
  
  # device file - lv创建完后会在目录下自动创建
  [root@RHEL8-RHCE vg1]$ ll /dev/vg1/
  total 0
  lrwxrwxrwx. 1 root root 7 Jan 28 19:34 lv1 -> ../dm-2
  lrwxrwxrwx. 1 root root 7 Jan 28 19:36 lv2 -> ../dm-3
  
  # dm - device mapper就是lv的本尊
  [root@RHEL8-RHCE vg1]$ ll .. | egrep "dm-2|dm-3"
  brw-rw----. 1 root    disk    253,   2 Jan 28 19:34 dm-2
  brw-rw----. 1 root    disk    253,   3 Jan 28 19:36 dm-3
  
  # remove
  [root@RHEL8-RHCE vg1]$ lvremove /dev/vg1/lv2
  Do you really want to remove active logical volume vg1/lv2? [y/n]: y
  Logical volume "lv2" successfully removed.
  
  # extend
  [root@RHEL8-RHCE vg1]$ lvextend /dev/vg1/lv1 -L 68M
  Size of logical volume vg1/lv1 changed from 32.00 MiB (8 extents) to 68.00 MiB (17 extents).
  Logical volume vg1/lv1 successfully resized.
  [root@RHEL8-RHCE vg1]$ lvs
  LV   VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root rhel -wi-ao---- <12.50g
  swap rhel -wi-ao----   1.50g
  lv1  vg1  -wi-a-----  68.00m
      
  # 此时扩容的部分并没有被格式化被文件系统所管理（只有sector没有block），所以看挂载的磁盘空间并没有看到大小增加
  # ext FS
  resize2fs <device file>
  # xfs FS
  xfs_growfs <mount directory>
  ```

- Others

  - `dd` - convert and copy a file

    ```bash
    # 测试硬盘写速度
    [root@RHEL8-RHCE vg1]$ dd if=/dev/zero of=/dev/null
    ^C2281529+0 records in
    2281528+0 records out
    1168142336 bytes (1.2 GB, 1.1 GiB) copied, 2.1252 s, 550 MB/s
    
    # 创建文件
    [root@RHEL8-RHCE ~]$ dd if=/dev/zero of=./file count=3 bs=1M
    3+0 records in
    3+0 records out
    3145728 bytes (3.1 MB, 3.0 MiB) copied, 0.00131961 s, 2.4 GB/s
    [root@RHEL8-RHCE ~]$ ll file
    -rw-r--r--. 1 root root 3145728 Jan 28 20:09 file
    
    # 创建厚置备的虚拟机硬盘文件 - 
    qeum-img create test 100G						# 不会立刻分配所有空间
    dd if=/dev/zero of=./test count=102400 bs=1M	# 会立刻分配所有空间
    ```
    
  - `ln` - make links between files
  
    ```bash
    # shortcut 
    # -s - soft
    ln -s /dev/sdc /root/sdc-link
    ```

### 5. Swap

- 当内存不足时，使用硬盘空间作为虚拟内存（速度↓）

  ```bash
  # check swap usage
  [tutorj@RHEL8-RHCE ~]$ free -h
                total        used        free      shared  buff/cache   available
  Mem:          1.8Gi       423Mi       371Mi       1.0Mi       1.0Gi       1.2Gi
  Swap:         1.5Gi          0B       1.5Gi
  
  [root@RHEL8-RHCE tutorj]$ fdisk -l /dev/sdc
  Device     Boot Start     End Sectors Size Id Type
  /dev/sdc1        2048 2099199 2097152   1G 83 Linux
  
  # make swap
  [root@RHEL8-RHCE tutorj]$ mkswap /dev/sdc1
  mkswap: /dev/sdc1: warning: don't erase bootbits sectors
          (dos partition table detected). Use -f to force.
  Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)
  no label, UUID=8144c3a0-c7c4-4e40-bf9f-ba917b756388
  
  # persist
  [root@RHEL8-RHCE tutorj]$ cat /etc/fstab | grep swap
  /dev/sdc1       swap    swap    defaults        0       0
  
  # enable & check
  [root@RHEL8-RHCE tutorj]$ swapon -a
  [root@RHEL8-RHCE tutorj]$ free -h
                total        used        free      shared  buff/cache   available
  Mem:          1.8Gi       443Mi       349Mi       1.0Mi       1.0Gi       1.2Gi
  Swap:         2.5Gi          0B       2.5Gi
  
  # disale
  swapoff -a
  swapoff /etc/fstab
  ```

### 5. nfs

- network file system

  ```bash
  # package required for both server & client
  [root@RHEL8-RHCE tutorj]$ rpm -qa | grep nfs-utils
  nfs-utils-2.3.3-57.el8.x86_64
  
  # create a partition
  [root@RHEL8-RHCE tutorj]$ fdisk -l /dev/sdc
  
  Device     Boot   Start     End Sectors Size Id Type
  /dev/sdc1          2048 2099199 2097152   1G 83 Linux
  /dev/sdc2       2099200 4196351 2097152   1G 83 Linux
  
  # formatting
  [root@RHEL8-RHCE tutorj]$ mkfs.ext4 /dev/sdc2
  mke2fs 1.45.6 (20-Mar-2020)
  Creating filesystem with 262144 4k blocks and 65536 inodes
  Filesystem UUID: 45a77f60-00e6-4851-928b-8e2dcf0e025f
  Superblock backups stored on blocks:
          32768, 98304, 163840, 229376
  
  Allocating group tables: done
  Writing inode tables: done
  Creating journal (8192 blocks): done
  Writing superblocks and filesystem accounting information: done
  
  # mount
  [root@RHEL8-RHCE tutorj]$ mkdir /nfs-share
  [root@RHEL8-RHCE tutorj]$ mount /dev/sdc2 /nfs-share
  [root@RHEL8-RHCE tutorj]$ df -Th | grep nfs
  /dev/sdc2             ext4      974M   24K  907M   1% /nfs-share
  
  # config on server
  [root@RHEL8-RHCE tutorj]$ cat /etc/exports
  /nfs-share 10.0.3.5/24(rw)
  
  # start service & stop firewall & selinux
  [root@RHEL8-RHCE tutorj]$ systemctl restart nfs-server
  [root@RHEL8-RHCE tutorj]$ systemctl enable nfs-server
  Created symlink /etc/systemd/system/multi-user.target.wants/nfs-server.service → /usr/lib/systemd/system/nfs-server.service.
  [root@RHEL8-RHCE tutorj]$ systemctl stop firewalld
  [root@RHEL8-RHCE tutorj]$ setenforce 0
  
  # check
  [root@RHEL8-RHCE tutorj]$ exportfs
  /nfs-share      10.0.3.5/24
  
  # client
  [root@RHEL8-RHCE tutorj]$ mkdir /nfs-mountpoint
  [root@RHEL8-RHCE tutorj]$ mount -t nfs 10.0.3.4:/nfs-share /nfs-mountpoint
  [root@RHEL8-RHCE tutorj]$ df -Th | grep nfs
  10.0.3.4:/nfs-share   nfs4      974M     0  907M   0% /nfs-mountpoint
  
  # cannot touch 
  [root@RHEL8-RHCE tutorj]$ touch /nfs-mountpoint/test
  touch: cannot touch '/nfs-mountpoint/test': Permission denied
  
  # server - add write permission to shared directoy
  [root@RHEL8-RHCE tutorj]$ ll -d /nfs-share/
  drwxr-xr-x. 3 root root 4096 Jan 29 10:22 /nfs-share/
  [root@RHEL8-RHCE tutorj]$ chmod o+w /nfs-share/
  [root@RHEL8-RHCE tutorj]$ ll -d /nfs-share/
  drwxr-xrwx. 3 root root 4096 Jan 29 10:22 /nfs-share/
  
  # great
  [root@RHEL8-RHCE tutorj]$ touch /nfs-mountpoint/test
  [root@RHEL8-RHCE tutorj]$ ll /nfs-mountpoint/test
  -rw-r--r--. 1 nobody nobody 0 Jan 29 10:32 /nfs-mountpoint/test
  
  # persist to /etc/fstab on client
  [root@RHEL8-RHCE tutorj]$ cat /etc/fstab | grep nfs
  10.0.3.4:/nfs-share     /nfs-mountpoint nfs     defaults 0      0
  
  # help
  man 5 exports
  ```

### 6. vdo

- Virtual Data Optimizer - since RHEL7

- A block virtualization that provides inline deduplication and compression of data at a block device level

- The idea of deduplication is quite simple: **to remove copies of duplicate data and only remain with one copy**. 

- Similar to ==秒传== - 上传大文件时做hash，并校验；如果发现相同，说明之前有人上传了相同的文件，并做软链接，节约后端存储空间

  ```bash
  # package required
  [root@RHEL8-RHCE tutorj]$ rpm -qa | grep vdo
  vdo-6.2.7.17-14.el8.x86_64
  kmod-kvdo-6.2.7.17-87.el8.x86_64
  
  # create VDO volume – make sure u have a device that is not partitioned
  lsblk
  sudo vdo create \
  --name=vdo1 \
  --device=/dev/xvdb \
  --vdoLogicalSize=300G
  
  # check dev mapper -> vdo
  ls -l /dev/mapper/vdo*
  
  # insight info in human-readable & verbose
  vdostats --hu
  vdostats --verbose /dev/mapper/vdo1
  
  # paritition – create pv & vg & check
  sudo pvcreate /dev/mapper/vdo1
  sudo vgcreate vdo1vg /dev/mapper/vdo1
  
  pvdisplay /dev/mapper/vdo1
  pvs
  vgdisplay vdo1vg
  vgs
  
  # create lv
  sudo lvcreate -n vdo1v01 -L 50G vdo1vg
  sudo lvcreate -n vdo1v02 -L 50G vdo1vg
  lvdisplay
  lvs
  
  # formatting
  # -K - Do not attempt to discard blocks at mkfs time
  sudo mkfs.xfs  -K /dev/vdo1vg/vdo1v01
  sudo mkfs.xfs  -K /dev/vdo1vg/vdo1v02
  
  # create mount point = dir
  # -o discard - discard/TRIM commands to the underlying block device when blocks are freed
  sudo mount -o discard /dev/vdo1vg/vdo1v01  /data/v01
  sudo mount -o discard /dev/vdo1vg/vdo1v02  /data/v02
  
  # check 
  vdostats --hu
  
  # persist to /etc/fstab
  /dev/dev/mapper/vdo1 /data/v01	xfs	default,_netdev	0 0
  /dev/dev/mapper/vdo2 /data/v02	xfs	default,_netdev	0 0
  ```

### 7. autofs

- 通过配置文件中的key，按需实现文件系统的自动挂载

```bash
# install
yum -y install libsss_autofs

# main config
[root@RHEL8-RHCE:~]$ cat /etc/auto.master
#
# Sample auto.master file
# This is a 'master' automounter map and it has the following format:
# mount-point [map-type[,format]:]map [options]
# For details of the format look at auto.master(5).
#
/misc   /etc/auto.misc				# 挂载点的父级目录 + 配置文件
#
# NOTE: mounts done from a hosts map will be mounted with the
#       "nosuid" and "nodev" options unless the "suid" and "dev"
#       options are explicitly given.
#
/net    -hosts
#
# Include /etc/auto.master.d/*.autofs
# The included files must conform to the format of this file.
#
+dir:/etc/auto.master.d
#
# If you have fedfs set up and the related binaries, either
# built as part of autofs or installed from another package,
# uncomment this line to use the fedfs program map to access
# your fedfs mounts.
#/nfs4  /usr/sbin/fedfs-map-nfs4 nobind
#
# Include central master map if it can be found using
# nsswitch sources.
#
# Note that if there are entries for /net or /misc (as
# above) in the included master map any keys that are the
# same will not be seen as the first read key seen takes
# precedence.
#
+auto.master


[root@RHEL8-RHCE:~]$ cat /etc/auto.misc
#
# This is an automounter map and it has the following format
# key [ -mount-options-separated-by-comma ] location
# Details may be found in the autofs(5) manpage

# cd is key
cd              -fstype=iso9660,ro,nosuid,nodev :/dev/sr1		# 挂载参数 + 挂载的设备文件

# the following entries are samples to pique your imagination
#linux          -ro,soft                ftp.example.org:/pub/linux
#boot           -fstype=ext2            :/dev/hda1
#floppy         -fstype=auto            :/dev/fd0
#floppy         -fstype=ext2            :/dev/fd0
#e2floppy       -fstype=ext2            :/dev/fd0
#jaz            -fstype=ext2            :/dev/sdc1
#removable      -fstype=ext2            :/dev/hdd

[root@RHEL8-RHCE:~]$ ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  
opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@RHEL8-RHCE:~]$ systemctl start autofs
# /msic created after service start
[root@RHEL8-RHCE:~]$ ls /
bin  boot  dev  etc  home  lib  lib64  media  misc  
mnt  net  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

# it points to /dev/sr1 which is defined in /etc/auto.misc
[root@RHEL8-RHCE:/misc]$ df -Th
Filesystem            Type      Size  Used Avail Use% Mounted on
devtmpfs              devtmpfs  877M     0  877M   0% /dev
tmpfs                 tmpfs     907M     0  907M   0% /dev/shm
tmpfs                 tmpfs     907M  9.0M  898M   1% /run
tmpfs                 tmpfs     907M     0  907M   0% /sys/fs/cgroup
/dev/mapper/rhel-root xfs        13G  7.0G  5.6G  56% /
/dev/sda1             xfs      1014M  342M  673M  34% /boot
tmpfs                 tmpfs     182M  4.0K  182M   1% /run/user/1000
[root@RHEL8-RHCE:/misc]$ ll cd
[root@RHEL8-RHCE:/misc]$ df -Th
Filesystem            Type      Size  Used Avail Use% Mounted on
devtmpfs              devtmpfs  877M     0  877M   0% /dev
tmpfs                 tmpfs     907M     0  907M   0% /dev/shm
tmpfs                 tmpfs     907M  9.0M  898M   1% /run
tmpfs                 tmpfs     907M     0  907M   0% /sys/fs/cgroup
/dev/mapper/rhel-root xfs        13G  7.0G  5.6G  56% /
/dev/sda1             xfs      1014M  342M  673M  34% /boot
tmpfs                 tmpfs     182M  4.0K  182M   1% /run/user/1000
/dev/sr1              iso9660   9.5G  9.5G     0 100% /misc/cd			# auto mounted
```

## Extra

### 1. recover root password

- 借助`initfs`进入到我们系统真正的fs中进行修改
  - 开机 -> `grub`选择`kernel` -> press `e` to edit
  - 在`Linux......quiet`所处行的最后添加`rd.break` -> `Ctrl + X` to save -> Emergency mode -> 进入`initfs`

```bash
# sysroot is read-only
# 是正式启动RHEL的 / 目录
# 这里重新挂载/sysroot并赋予读写全息，之后便可进行修改
mount -o rw.remount /sysroot

# 将/sysroot作为当前initfs的根目录
chroot /sysroot

# changed root password under
/etc/shadow

# change password
passwd root

# if SElinux is enable
touch /.autorelabel
```

### 2. archiving

#### 1. gzip

- `gzip/gunzip`  - compress or decompress files

- `zcat`  - uncompresses either a list  of files on the cmd line or its STDIN and writes the uncompressed data on STDOUT

- `zmore/zless` - file perusal filter for crt viewing of compressed text

  ```bash
  # -c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；
  # -d ：解压缩的参数；
  # -t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；
  # -v ：可以显示出原文件/压缩文件的压缩比等信息；
  # -# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6
  gzip [option] file
  
  # zip - original file will be gone
  [tutorj@RHEL8-RHCE ~]$ gzip -v hosts
  hosts:   60.1% -- replaced with hosts.gz
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 103 Jan 15 16:13 hosts.gz
  
  # zcat
  [tutorj@RHEL8-RHCE ~]$ zcat hosts.gz
  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
  10.0.3.4    RHEL8-RHCE.local RHEL8-RHCE
  
  # unzip
  [tutorj@RHEL8-RHCE ~]$ gzip -d hosts.gz
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  [tutorj@RHEL8-RHCE ~]$ gunzip hosts.gz
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  
  # zmore/zless
  zmore *.gz
  zless *.gz
  ```

#### 2. bzip2

- `bzip2/bzunip2` - a block-sorting file compressor/decompressor

- `bzcat` - decompresses all specified files to the standard output

- `bzmore/bzless` - file perusal filter for crt viewing of bzip2 compressed text

- `bzgrep/bzegrep/bzfgrep` - search possibly bzip2 compressed files for a regular expression

- `bzip2recover` - recovers data from damaged bzip2 files

  ```bash	
  # -c ：将压缩的过程产生的数据输出到屏幕上！
  # -d ：解压缩的参数
  # -k ：保留原始文件，而不会删除原始的文件喔！
  # -z ：压缩的参数 （默认值，可以不加）
  # -v ：可以显示出原文件/压缩文件的压缩比等信息；
  # -# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！
  bzip2 [option] file
  
  # zip
  [tutorj@RHEL8-RHCE ~]$ bzip2 -v hosts
    hosts:    1.623:1,  4.929 bits/byte, 38.38% saved, 198 in, 122 out.
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 122 Jan 15 16:13 hosts.bz2
  
  # cat
  [tutorj@RHEL8-RHCE ~]$ bzcat hosts.bz2
  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
  10.0.3.4    RHEL8-RHCE.local RHEL8-RHCE
  
  # grep
  [tutorj@RHEL8-RHCE ~]$ bzgrep RHEL hosts.bz2
  10.0.3.4    RHEL8-RHCE.local RHEL8-RHCE
  
  # unzip
  [tutorj@RHEL8-RHCE ~]$ bzip2 -d hosts.bz2
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  [tutorj@RHEL8-RHCE ~]$ bunzip2 hosts.bz2
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  ```

#### 3. xz

- `xz/unxz` - Compress or decompress .xz files

- `xzcat` - decompresses all specified files to the standard output

- `xzmore/xzless` - view xz compressed (text) files

- `xzgrep/xzegrep/xzfgrep` - search compressed files for a regular expression

  ```bash	
  # -d ：就是解压缩啊！
  # -t ：测试压缩文件的完整性，看有没有错误
  # -l ：列出压缩文件的相关信息
  # -k ：保留原本的文件不删除～
  # -c ：同样的，就是将数据由屏幕上输出的意思！
  # -# ：同样的，也有较佳的压缩比的意思！
  xz [option] file
  
  # zip
  [tutorj@RHEL8-RHCE ~]$ xz -v hosts
  hosts (1/1)
    100 %               144 B / 198 B = 0.727
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 144 Jan 15 16:13 hosts.xz
  
  # cat
  [tutorj@RHEL8-RHCE ~]$ xzcat hosts.xz
  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
  10.0.3.4    RHEL8-RHCE.local RHEL8-RHCE
  
  # grep
  [tutorj@RHEL8-RHCE ~]$ xzgrep RHEL8-RHCE hosts.xz
  10.0.3.4    RHEL8-RHCE.local RHEL8-RHCE
  
  # unzip
  [tutorj@RHEL8-RHCE ~]$ xz -d hosts.xz
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  [tutorj@RHEL8-RHCE ~]$ unxz hosts.xz
  [tutorj@RHEL8-RHCE ~]$ ll | grep hosts
  -rw-r--r--. 1 tutorj tutorj 198 Jan 15 16:13 hosts
  ```

#### 4. tar

- `tar` - an archiving utility

  ```bash
  # -z ：通过 gzip 的支持进行压缩/解壓縮：此时文件名最好为  *.tar.gz
  # -j ：通过 bzip2 的支持进行压缩/解壓縮：此时文件名最好为 *.tar.bz2
  # -J ：通过 xz 的支持进行压缩/解壓縮：此时文件名最好为    *.tar.xz
  
  # -f : 处理的文件名！建议 -f 单独写一个选项啰！
  # -p ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件
  # -P ：保留绝对路径，亦即允许备份数据中含有根目录存在之意
  # -v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！
  
  # zip - c
  # -x ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开
  # -c ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）
  [tutorj@RHEL8-RHCE ~]$ time tar -zpc -f etc.tar.gz /etc 2> /dev/null
  real    0m1.229s
  user    0m1.144s
  sys     0m0.043s
  [tutorj@RHEL8-RHCE ~]$ time tar -jpc -f etc.tar.bz2 /etc 2> /dev/null
  real    0m2.606s
  user    0m2.498s
  sys     0m0.044s
  [tutorj@RHEL8-RHCE ~]$ time tar -Jpc -f etc.tar.xz /etc 2> /dev/null
  real    0m16.264s
  user    0m15.803s
  sys     0m0.146s
  [tutorj@RHEL8-RHCE ~]$ ll -h | grep etc | awk '{print $5,$9}' | sort -nr
  8.4M etc.tar.gz
  6.7M etc.tar.bz2
  5.6M etc.tar.xz
  
  # zip & exclude
  # --exclude
  [tutorj@RHEL8-RHCE ~]$ tar -zc -f tutorj_home.tar.gz --exclude=Desktop --exclude=Documents .
  [tutorj@RHEL8-RHCE ~]$ tar -zt -f tutorj_home | egrep "Desktop|Documents"
  [tutorj@RHEL8-RHCE ~]$
  
  # zip only newer time
  # --newer       -  newer than mtime（内容修改） & ctime（權限屬性修改）
  # --newer-mtime -  only mtime（内容修改）
  tar -zc -f newer.tar.gz --newer-mtime="yyyy/mm/dd" /etc/*
  
  # check
  # -t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了
  [tutorj@RHEL8-RHCE ~]$ tar -zt -f etc.tar.gz | head -3
  etc/
  etc/mtab
  etc/fstab
  [tutorj@RHEL8-RHCE ~]$ tar -jt -f etc.tar.bz2 | head -3
  etc/
  etc/mtab
  etc/fstab
  [tutorj@RHEL8-RHCE ~]$ tar -Jt -f etc.tar.xz | head -3
  etc/
  etc/mtab
  etc/fstab
  
  # unzip - x
  # -C ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项
  tar -zx -f etc.tar.gz -C .
  tar -jx -f etc.tar.bz2 -C .
  tar -Jx -f etc.tar.xz -C .
  
  # zip only a file - get from check
  [tutorj@RHEL8-RHCE ~]$ tar -zt -f etc.tar.gz | grep shadow
  etc/pam.d/sssd-shadowutils
  [tutorj@RHEL8-RHCE ~]$ tar -zx -f etc.tar.gz etc/pam.d/sssd-shadowutils
  [tutorj@RHEL8-RHCE ~]$ ll etc/pam.d/sssd-shadowutils
  -rw-r--r--. 1 tutorj tutorj 214 Oct 14 05:01 etc/pam.d/sssd-shadowutils
  ```

### 3. tuned

```bash
# 考题
[root@host-1 ~]$ tuned-adm recommend
virtual-guest
[root@host-1 ~]$ tuned-adm profile virtual-guest
[root@host-1 ~]$ tuned-adm active
Current active profile: virtual-guest
```