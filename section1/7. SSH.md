[toc]

# SSH

## 1. 加密算法

- 无论哪种加密算法都分为加密和解密，都需要密钥，各有优缺点，要结合使用

### 1. 对称加密

- 加密和解密都使用==同一个密钥==，一般加密长度越长越好
- 类型
  - `DES` - Data Encryption Standard     - 40/56/**168**
  - `AES` - Advanced Encryption Standard - 128/192/**256**
- 思考：
  - Bob如何将密钥安全传给Alice？
    - 无法确保密钥的安全传递:pensive:
  - 除了Alice & Bob外，多人两两之间能否用相同密钥进行加密？
    - 不合适，无法保证两两之间的消息保密性:pensive:
    - 需要的密钥数：`N * (N-1) / 2`

### 2. 非对称加密

- 加密和解密使用不同的密钥 - 公钥 & 私钥
- 公钥加密只能用私钥解开，vice versa
- 公钥能够被共享出去
- 类型
  - `RSA` - Rivest,Shamair,Adleman - 长度可以指定
- 思考
  - 需要的密钥数：`2N`
  - 随着加密的数据增大，加密的时间也会越长:pensive:

### 3. 数据加密终极解决

1. Bob生成非对称加密生成公私钥对

2. Alice使用对称加密生成对称密钥

3. Bob共享公钥

4. Alice使用Bob公钥加密对称密钥

5. Bob使用私钥解密对称密钥

   --- 👆 保证对称密钥安全传输 👆 ---

6. Bob使用对称密钥加密数据

7. Alice使用对称密钥解密

   

   思考

   - 传输的数据仅仅加密就安全了嘛？
     - 加密的数据可能被篡改:pensive:

### 4. Hash/Digest

- 每一个数据包后到带上一个校验和checksum，如果接收方发现计算的校验和附带的不一致，索命数据发生了便宜or错误，可以选择丢弃or重传

- ==Hash对任何大小的数据计算除的Hash值长度都是一样的，且不可逆==

- Hash多用于认证，只需要交换密码的Hash值即可

- 类型

  - `MD5` - Message Digest 5      - 128

    ```bash
    # get file md5sum
    md5sum <file>
    ```

  - `SHA` - Secure Hash Algorithm - 160/256/512

### 5. Digital Signature

1. Bob使用非对称加密生成密钥对

2. Bob共享公钥

3. Bob计算传输数据Hash值

4. Bob使用私钥对Hash值进行签名

5. Bob将加密数据和签名一并传给Alice

6. Alice解密获得数据和签名

   --- 👆 确认是Bob发过来的 👆 ---

7. Alice使用Bob的公钥加密签名得到Hash值

8. Alice对数据进行Hash，与刚才的Hash进行比较

   --- 👆 确认数据没有被篡改 👆 ---

   

   思考

   - 无法判断Bob是否真的是Bob:pensive:

### 6. CA

1. Bob将自己的公钥和个人信息交给`CA`进行私钥签名获得数字证书
2. Bob将数字证书和公钥传给Alice
3. Alice使用`CA`的公钥对数字证书进行验证，得到Bob公钥的Hash值
4. Alice对Bob的公钥进行Hash，与刚才的Hash进行比较

### 7. Summary

1. 传输数据必须加密   - 对称+非对称结合
2. 传输数据不能被篡改  - Hash/Digest
3. 传输数据必须有签名  - 私钥签名，公钥验证
4. 必须进行身份认证    - CA数字证书
5. 防止重放攻击       - 随机数

## 2. SSH

- Secure Shell - 应用层服务 - 提供安全的远程连接

  - 需要先建立TCP连接
  - 服务器想要作为SSH Server，前提必须要有一对非对称的密钥；
    - 必须要把自己的公钥share出去让客户端加密
  
  ```bash
  # change hostname
  hostnamectl set-hostname <name>
  
  # login
  # 如果不指定username，会使用当前client shell的user来尝试访问
  # 若服务器没有该user，是不可能登录的
  ssh <username>@<ip>
  ssh <username>@<ip> -p <port>
  ssh <ip> -l <login name>
  
  # 远程执行一个命令
  ssh <username>@<ip> <cmd>
  ```
### 1. fingerprint & known_hosts

  ```bash
  # SSH key pair under /etc/ssh
  # 默认有3对 - ecdsa/ed25519/rsa - 非对称加密算法
  # 为了适配不同种类的客户端
  [root@RHEL8-RHCE ssh]$ ll
  total 600
  -rw-r--r--. 1 root root     577388 Jun 30  2022 moduli
  -rw-r--r--. 1 root root       1770 Jun 30  2022 ssh_config
  drwxr-xr-x. 2 root root         28 Jun 30  2022 ssh_config.d		        # SSH客户端配置文件
  -rw-------. 1 root root       4267 Jun 30  2022 sshd_config               # SSH服务端配置文件
  -rw-r-----. 1 root ssh_keys    492 Dec  6 23:28 ssh_host_ecdsa_key
  -rw-r--r--. 1 root root        162 Dec  6 23:28 ssh_host_ecdsa_key.pub
  -rw-r-----. 1 root ssh_keys    387 Dec  6 23:28 ssh_host_ed25519_key
  -rw-r--r--. 1 root root         82 Dec  6 23:28 ssh_host_ed25519_key.pub
  -rw-r-----. 1 root ssh_keys   2578 Dec  6 23:28 ssh_host_rsa_key
  -rw-r--r--. 1 root root        554 Dec  6 23:28 ssh_host_rsa_key.pub
  ```

  ```bash
 # SSH服务端配置 - 指定了3个私钥
[root@RHEL8-RHCE ssh]$ grep "HostKey" sshd_config
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
  
# 当没有密钥对时，连接报错
[root@RHEL8-RHCE ssh]$ ssh local
ssh_exchange_identification: read: Connection rest by peer
  ```

  ```bash
  # login as tutorj，default 22
  [tutorj@RHEL8-RHCE ~]$ ssh localhost
  The authenticity of host 'localhost (::1)' can't be established.
  ECDSA key fingerprint is SHA256:xvgHUX7ryNxhV1Hlf2RKy9lUx83Hplxq4NCjVP4W15M.
  Are you sure you want to continue connecting (yes/no/[fingerprint])? 
  
  # tcp connection - 此时TCP已经建立了连接，SSH Session还没有完全建立，还需要指纹验证
  [root@RHEL8-RHCE .ssh]$ netstat -tunp | grep ssh
  tcp        0      0 10.0.3.4:22             10.0.3.2:13600          ESTABLISHED 5901/sshd: tutorj 
  
  # 服务端生成指纹，与上面一致的，就能判断访问的是正确的服务器
[root@RHEL8-RHCE ssh]$ ssh-keygen -lf ssh_host_ecdsa_key
  256 SHA256:xvgHUX7ryNxhV1Hlf2RKy9lUx83Hplxq4NCjVP4W15M ssh_host_ecdsa_key.pub (ECDSA)
  # print different format
  [root@RHEL8-RHCE ssh]$ ssh-keygen -lf ssh_host_ecdsa_key -E md5
  256 MD5:07:bb:20:7d:d0:e4:45:bc:cc:1f:13:8d:85:bf:c3:cd ssh_host_ecdsa_key.pub (ECDSA)
  [root@RHEL8-RHCE ssh]$ ssh-keygen -lf ssh_host_ecdsa_key -E sha1
  256 SHA1:DlWKUnjLkkke8u1tLaISI19Q0Bc ssh_host_ecdsa_key.pub (ECDSA)
  [root@RHEL8-RHCE ssh]$ ssh-keygen -lf ssh_host_ecdsa_key -E sha256
  256 SHA256:xvgHUX7ryNxhV1Hlf2RKy9lUx83Hplxq4NCjVP4W15M ssh_host_ecdsa_key.pub (ECDSA)
  [root@RHEL8-RHCE ssh]$ ssh-keygen -lf ssh_host_ecdsa_key -E sha512
  256 SHA512:i7M99kPDT1ycoTqNqjWDEK5M0MMSICaRe8kXD9abemSqRpyf/xq7xBaakMAdzcAk/jg2gsR3JtL/GoRN2DAyCg ssh_host_ecdsa_key.pub (ECDSA)
  
  
  # 输入了yes之后
  [tutorj@RHEL8-RHCE ~]$ ssh localhost
  The authenticity of host 'localhost (::1)' can't be established.
  ECDSA key fingerprint is SHA256:xvgHUX7ryNxhV1Hlf2RKy9lUx83Hplxq4NCjVP4W15M.
  Are you sure you want to continue connecting (yes/no/[fingerprint])? yes      # 输入了yes之后
  Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.
  tutorj@localhost's password:
  Activate the web console with: systemctl enable --now cockpit.socket
  
  Register this system with Red Hat Insights: insights-client --register
  Create an account or view all your systems at https://red.ht/insights-dashboard
  Last login: Mon Jan 23 15:31:40 2023 from 10.0.3.2
  
# entry added to ~/.ssh/known_hosts
  # 记录客户端的公钥 = 指纹，服务器就可以使用公钥进行加密，后续客户端再次SSH就不需要认证指纹
  # 如果客户端的IP改变，服务器没有再known_hosts中找到，就需要再次认证指纹
  [root@RHEL8-RHCE .ssh]$ cat known_hosts
  localhost ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBE+kk1+W0K2MUSuucI1EXio9TpRhEOsvtw+CpvcNGRwxQn1ngNmLqJ+bkpZTjis9jPKZ2vfTEWlnPYa4tijOObM=
  ```

```bash
# skip fingerprint authentication
ssh -o StrictHostKeyChecking=no <username>@<ip>
```

### 2. sshd_config

```bash
# 修改配置后需要重启服务
# 可能同时还需要修改SELinux和Firewall
[root@RHEL8-RHCE ssh]$ vim sshd_config

# 监听端口
Port 22
# 监听地址 - 0.0.0.0表示所有ipv4地址的22端口
ListenAddress 0.0.0.0
# 允许root登录ssh
PermitRootLogin yes
# 支持基于公钥的认证
PubkeyAuthentication yes
# 开启公钥认证后，客户端公钥的存放位置
AuthorizedKeysFile      .ssh/authorized_keys
# 支持密码认证
PasswordAuthentication yes
# 是否支持X11转发
X11Forwarding no
```

### 3. 基于公钥免密登录

- 需要开启`PubkeyAuthentication`

    1. 客户端通过`ssh-keygen`生成非对称密钥对

       ```bash
       [hiron.DESKTOP-MRRKMSM] ➤ ssh-keygen
       Generating public/private rsa key pair.
       Enter file in which to save the key (/home/mobaxterm/.ssh/id_rsa):  # 密钥对存放目录
       Enter passphrase (empty for no passphrase):                         # 私钥密码，可为空
       Enter same passphrase again:
       Your identification has been saved in /home/mobaxterm/.ssh/id_rsa.
       Your public key has been saved in /home/mobaxterm/.ssh/id_rsa.pub.
       The key fingerprint is:
       SHA256:yC3U/+o4+EgHNWaRb9JMBv0NKNf09TIh2Eqfz3cM7I4 hiron@DESKTOP-MRRKMSM
       The key randomart image is:
       +---[RSA 2048]----+
       |        o+ *o . .|
       |       .o.O +o o.|
       |      . *X + =+ .|
       |     o *.o* + +o |
       |      = So.  + o |
       |       o   .  + +|
       |      ...   .o ..|
       |     ..o.. .E .  |
       |      ..ooo      |
       +----[SHA256]-----+
       ```

    2. 客户端访问采用基于公钥的认证方式

    3. 客户端的公钥传到服务器

       ```bash
       [2023-01-23 17:02.10]  ~/.ssh
       [hiron.DESKTOP-MRRKMSM] ➤ ll
       total 3
       -rw-r--r--    1 hiron    UsersGrp      1675 Jan 23 17:01 id_rsa
       -rw-r--r--    1 hiron    UsersGrp       403 Jan 23 17:01 id_rsa.pub
       -rw-r--r--    1 hiron    UsersGrp       565 Dec  6 19:43 known_hosts
       
       # copy
       [hiron.DESKTOP-MRRKMSM] ➤ cat id_rsa.pub
       ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCkdjbGajb4llwZEXwIt1HmGtymExI6xzcHO/bIpn5UpIMyMrinqe7ikndA5D5cQdxeQ95GZibxojt4ZX902UI/p7DWPA/iORZeAMTg0p1NZ5QiGi9TFC5M5U4K+Dp4ClBDzxavkKy3lsRg/iSde5FrmJOxefZ0osOHKMP/UbqZozs8UiEq8NpJ3roBZ8pZHqS5jYemtkd/Crnc662iy8nr4OSh3X6YRAZnM4CuB2/zKzGQ2R8EQVeqaJSLcUBNUcQZcD1skSrS6gnNxu6M+rk190bOKrCzKtbumfdv5ztxHqR5Qns2KoNDL5TMjn52Qk77kOveBOfx3HopUGaA8L15 hiron@DESKTOP-MRRKMSM
       
       # 服务器存放客户端公钥位置
       [root@RHEL8-RHCE ssh]$ vim sshd_config
       AuthorizedKeysFile      .ssh/authorized_keys
       ```

       ```bash
       # another way to copy client public key to server
       ssh-copy-id <username>@<ip>
       
       # 之后可以使用指定的私钥连接
       ssh -i <identity_file> <username>@<ip>
       ```

### 4. scp/sftp

- `scp` - secure copy (remote file copy program)

  ```bash
  # -P - 注意是大写，指定端口号
  # copy to
  [tutorj@RHEL8-RHCE ~]$ scp file tutorj@localhost:~/file_scp
  tutorj@localhost's password:
  file                              100%    0     0.0KB/s   00:00
  [tutorj@RHEL8-RHCE ~]$ ll | grep file
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:28 file
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:28 file_scp
  
  # copy back
  [tutorj@RHEL8-RHCE ~]$ scp tutorj@localhost:~/file_scp file_scp_back
  tutorj@localhost's password:
  file_scp                          100%    0     0.0KB/s   00:00
  [tutorj@RHEL8-RHCE ~]$ ll | grep file
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:28 file
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:28 file_scp
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:31 file_scp_back
  ```

- `sftp` - secure file transfer program

  ```bash
  # -r - recursively copy
  [tutorj@RHEL8-RHCE ~]$ sftp tutorj@localhost
  tutorj@localhost's password:
  Connected to tutorj@localhost.
  sftp> pwd
  Remote working directory: /home/tutorj
  sftp> get file
  Fetching /home/tutorj/file to file
  sftp> exit
  [tutorj@RHEL8-RHCE ~]$ ll | grep file
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:33 file     # mtime changed
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:28 file_scp
  -rw-rw-r--. 1 tutorj tutorj   0 Jan 23 16:31 file_scp_back
  ```

### 4. sshpass

- `sshpass` - noninteractive ssh password provider - 使用非交互式使用SSH密码验证

  - `ssh`使用直接`tty`访问确保密码是由交互式键盘用户发出的

  - `sshpass`使用专用的`tty`运行`ssh`，让ssh server认为是从交互式用户发出密码的

    ```bash
    # install
     yum -y install sshpass
    
    # 1. 使用密码（不推荐）
    # -p - specify password
    sshpass -p "<pwd>" ssh <username>@<host>
    sshpass -p "<pwd>" ssh -o StrictHostKeyChecking=no<username>@<host>
    
    # 2. 使用文件
    # -f - specify password file
    echo 'pwd' > pass
    chmod 400 pass
    sshpass -f pass ssh <username>@<host>
    sshpass -f pass ssh -o StrictHostKeyChecking=no <username>@<host>
    
    # 3. 使用SSHPASS环境变量
    SSHPASS='<pwd>' && sshpass -e ssh username@rumenz.com
    SSHPASS='<pwd>' && sshpass -e ssh -o StrictHostKeyChecking=no username@rumenz.com
    ```

### 5. Handshake (TODO)

## Extra

