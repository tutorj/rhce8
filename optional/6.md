[toc]

# IP

## 1. Binary/Hexadecimal

- Binary/Hexadecimal -> Deciaml - 加权求和
- Decimal -> Binary/Hexadecimal - 除2/16取余

## 2. IP - Internet Protocol

- Characteristic

  - **Connectionless - 无连接**

  - Packests treated independetly

  - **Hierachical addressing - 分层编址**

  - **Best-effort delivery - 尽最大努力交付**

  - **No data-receovery features - 无数据重传机制**

  - Media-independent

  - IPv4 & IPv6

    

- IP Address Representation - 点分十进制

  - Each host must have a unique address

  - 4 Bytes - 32 bits - 2 parts

    - ==网络位== - 标识host所在的网络，路由器使用用于维护路由信息；如果两个host的网络地址相同，说明这两台host处于同一个网络

    - ==主机位== - 标识host个体；用于衡量网络的大小 = 主机的个数

      - All `0` - 代表这是一个网络地址
      - All `1` - 代表这是一个广播地址

      

  <img src="https://gridinsoft.com/img/article/ip-address/ip-address.png" alt="What is an IP address - Definition and Explanation | Gridinsoft" style="zoom: 67%;" />

- Public IP Address - Classified

  

  <img src="https://miro.medium.com/max/1200/1*wbYRk65-lnwsWYSFJ656xw.png" alt="Tricks to remember five classes of IPv4 | by Geeky much! | Networks &  Security | Medium" style="zom:67%;" />



- Private IP Address - Classified

  - Issue:pensive:: 如果企业网络中希望规划多个网段来隔离物理网络上的主机，使用缺省子网掩码就会存在一定的局限性

    - 网路中划分多个网段后，每个网段中的实际主机数量可能有限，一个网段内可能并不需要那么多主机，导致很多地址未使用，地址使用率很低

      


  <img src="https://citshub.files.wordpress.com/2017/03/private-ip-address.jpg?w=840" alt="Private-IP-Address" style="zoom:50%;" />

  

- Broadcast Address 

  - Directed - `192.168.1.255`   - 主机位全为1，拥有相同的本地广播地址才会接收
  - Local    - `255.255.255.255` - IP地址全为1，所有网段都可以接收
    - （不知道自己IP的情况 = 不知道自己属于哪个网络）向DHCP请求分配IP

## 3. [IP Header](https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Header)

- `Version` - 4 bits
  - `0100` - IPv4
  - `0110` - IPv6
- `IHL` - Internet Header Length - 4 bits
  - `0101` - 5 -> 20 Bytes (min)
  - `0110` - 6 -> 24 Bytes
- `TOC` - 8 bits
- `Total Len` - 16 bits (0~65536 but MTU - 1500 Bytes max) + 14 Bytes (Frame Header) -> Effective Payload
- `Identification` - 16 bits -  for slicing，标识packet属于哪个segment
- `Flag` - 3 bits - for slicing - 标识是否是segment中最后一个packet
  - bit 1 - reserved
  - bit 2 - DF
  - bit 3 - MF
- `Fragment Offset` - 13 bits - for slicing - 标识packet在segment中的顺序
- `Time to Live` - 8 bits - 0~255
  - 每经过一个L3设备，都减1
  - 丢弃if 0
  - 如果避免永久环路
- `Protocol` - 8 bits
  - `1`  - `ICMP`
  - `6`  - `TCP`
  - `17` - `UDP`
  - `88` - `EIGRP`
  - `89` - `OSPF`
- `Header Checksum` - 确认packet是否有损坏
- `Source Address` - 32 bits
- `Destination Address` - 32 bits
- `Options` - 可选
- `Padding` - 填充if可选is used



- IPv4 -> IPv6
  - **取消了首部校验和字段**
    
    - 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
  - **取消了分片/重新组装相关字段**
    
    - 分片与重组是耗时的过程，IPv6不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
  - **取消选项字段**
    - 选项字段不再是标准IP首部的一部分了，但它并没有消失，而是可能出现在IPv6首部中的「下一个首部」指出的位置上
    - 删除该选项字段使的IPv6的首部成为固定长度的`40`字节
    
      

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/31.jpg" alt="IPv4 首部与 IPv6 首部的差异" style="zoom: 50%;" />

## 4. DNS

- 域名解析 - hostname <-> IP
- 迭代 & 递归

## 5. Mask

- 因为有类IP的划分，导致IP的分配不灵活，容易造成IP的浪费

  

- 掩码 - Mask - 和IP地址的表示方法一样，但必须是连续的`0`和`1`，且前面必须是`1`

  - 掩码的`1`标记了网络位
  - 掩码的`0`标记了主机位
  - 例：192.168.1.5/24
    - 网络位 - 192.168.1.0/24；该网络里可有2^8 - 2 = 254台主机
      - 如何获取？==IP地址和掩码进行“与”操作->网络位==
    - 主机位 - 5

## 6. VLSM

- `VLSM` - Variable Length Subnet Mask - 可变长子网掩码

  - 增加子网掩码的长度

    - `192.168.1.0/24` -> `192.168.1.0/25`，掩码+1 -> 将原本一个网络变成2个网络，但主机位减少了 = 可用IP减少

      - `192.168.1.0/25`

        - IP   - 11000000.10101000.00000001.0 | 0000000 
        - Mask - 11111111.11111111.11111111.1 | 0000000

      - `192.168.1.128/25`

        - IP   - 11000000.10101000.00000001.1 | 0000000

        - Mask - 11111111.11111111.11111111.1 | 0000000

          

- 需求#1 - 4个部门，每个部门需要20个IP；该公司申请了C类地址 - `192.168.134.0/24`，请给出合理的子网划分方案

  ```bash
  # 4个部门 = 4个网络，所以要增加2位掩码
  11000000 10101000 10000110 | 0000000 # 192.168.134.0/24 
  ↓
  # 每个网络里有6位主机会，最多支持64 - 2 = 62台主机，可以满足需求
  11000000 10101000 10000110  00 | 00000 # 192.168.134.0/26
  11000000 10101000 10000110  01 | 00000 # 192.168.134.64/26 
  11000000 10101000 10000110  10 | 00000 # 192.168.134.128/26 
  11000000 10101000 10000110  11 | 00000 # 192.168.134.192/26 
  ```

- 需求#2 - 新增1个部门，也需要20个IP，请给出合理的子网划分方案

  ```bash
  # 根据网络数量分析扩展性不好，所以应该通过主机数量分析！！！
  # 2^n -2 >= 20即可，∴n取5
  # 掩码 = 32 - 5 = 27
  11000000 10101000 10000110 | 0000000 # 192.168.134.0/24 
  ↓
  # 每个网络里有5位主机位，最多支持32 - 2 = 30台主机，可以满足需求
  # 网络地址 - 192.168.134.0/27
  # 可用地址 - 192.168.134.1/27 ~ 192.168.134.29/27
  # 网关地址 - 192.168.134.30/27
  # 广播地址 - 192.168.134.31/27
  11000000 10101000 10000110 000 | 00000	# 192.168.134.0/27
  11000000 10101000 10000110 001 | 00000	# 192.168.134.32/27
  11000000 10101000 10000110 010 | 00000	# 192.168.134.64/27
11000000 10101000 10000110 011 | 00000	# 192.168.134.96/27
  11000000 10101000 10000110 100 | 00000	# 192.168.134.128/27
  11000000 10101000 10000110 101 | 00000	# 192.168.134.160/27
  11000000 10101000 10000110 110 | 00000	# 192.168.134.192/27
  11000000 10101000 10000110 111 | 00000	# 192.168.134.224/27
  ```
  
- 需求#3 - A需要100个，B需要50个，C和D需要25个，公司申请了一个C类 - `192.168.147.0/24`，请给出合理的子网划分方案

  ```bash
  # A需要100个IP，2^n - 2 >= 100, n取7
  11000000 10101000 10010011 0 | 0000000 # 192.168.147.0/25   -> A
  11000000 10101000 10010011 1 | 0000000 # 192.168.147.128/25 -> B/C/D
  
  # B需要50个IP，2^n - 2 >= 50, n取6
  11000000 10101000 10010011 10 | 000000 # 192.168.147.128/26 -> B
  11000000 10101000 10010011 11 | 000000 # 192.168.147.192/26 -> C/D
  
  # C/D需要25个IP，2^n - 2 >= 20, n取5
  11000000 10101000 10010011 110 | 00000 # 192.168.147.192/26 -> C
  11000000 10101000 10010011 111 | 00000 # 192.168.147.224/26 -> D
  ```

- ==练习题==

  

  <img src="D:\rhce8\optional\img\image-20230123142759570.png" alt="image-20230123142759570" style="zoom:50%;" />

  

  ```bash
  # 根据主机数量进行分析，2^n -2 >= 50, n取6
  # 主机位：6
  # 网络位：32 - 6 = 26
  # 多了26 - 20 = 6 -> 2^6 = 64个网络
  
  
  10101100 00010000 0010 | 0000 00000000 # 172.16.32.0/20
  11111111 11111111 1111 | 0000 00000000 
  ↓
  # 新增的网络位实际上是原来的主机位，主机位即可以是0也可以是1
  10101100 00010000 0010 | 0000 00 | 000000 # 172.16.32.0/26
  10101100 00010000 0010 | 0000 01 | 000000 # 172.16.32.64/26
  10101100 00010000 0010 | 0000 10 | 000000 # 172.16.32.128/26
  10101100 00010000 0010 | 0000 11 | 000000 # 172.16.32.192/26
  10101100 00010000 0010 | 0001 00 | 000000 # 172.16.33.0/26
  10101100 00010000 0010 | 0001 01 | 000000 # 172.16.33.64/26
  ...
  10101100 00010000 0010 | 1111 11 | 000000 # 172.16.63.192/26
  
  # 多了26 - 20 = 6 -> 2^6 = 64个网络
  # 有4个网络需要50个IP，还剩下60个
  
  # 两个路由器相连，两个接口分别需要一个网络2个IP = 2个主机
  # 2^n - 2 >= 2，取n = 2
  # 主机位：2
  # 网络位：30
  
  # 从剩下60个中挑一个出来
  # 该网络主机位有6位
  # 现在需要2位主机位
  # 还剩下4位主机位作网络位,总共16个网络
  10101100 00010000 00100001 00 | 000000 # 172.16.33.0/26
  ↓
  10101100 00010000 00100001 00 | 0001 | 00 # 172.16.33.4/30
  10101100 00010000 00100001 00 | 0010 | 00 # 172.16.33.8/30
  10101100 00010000 00100001 00 | 0011 | 00 # 172.16.33.12/30
  10101100 00010000 00100001 00 | 0100 | 00 # 172.16.33.16/30
  10101100 00010000 00100001 00 | 0101 | 00 # 172.16.33.29/30
  ...
  10101100 00010000 00100001 00 | 1111 | 00 # 172.16.33.60/30
  
  # 现在需要4个网络，拿出4个即可
  ```

## 7. CIDR

- 需求 - 有一个网络，该公司需要500个IP地址

  - 1个C类256个IP，2个C类可以搞定，但是两个网络，不满足

    ```bash
    # 192.168.0.0/24
    # 192.168.0.1/24
    11000000 10101000 00000000 | 00000000
    11000000 10101000 00000001 | 00000000
    ↓
    # 192.168.0.0/23
    11000000 10101000 0000000 | 0 | 00000000
    11000000 10101000 0000000 | 1 | 00000000
    
    # 将掩码向左移动一位，原来的2个网络变成了1个网络，新增了1个主机位
    
    ```

    

- `VLSM`的本质是通过增加掩码长度来增加网络/网段
- `CIDR` - Classless Inter-Domain Routing - 无类域间路由 - 通过缩短掩码长度来增加主机，实现网络的聚合 -> ==超网==
  - 192.168.0.0/16
  - 192.0.0.0/8
  - 0.0.0.0/0 （缺省网络）

## 8. IP Configuration (TODO)

```bash
# into interface mode
interface e{x/y}

# config ip
ip add <ip> <mask>
```

